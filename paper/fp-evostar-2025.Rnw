\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\newcommand{\pinp}{\texttt{pinpoint}}
\newcommand{\lik}{\texttt{likwid}}

\begin{document}
\title{Optimizing energy consumption of BBOB fitness functions}

%\author{
%  Juan J. Merelo-Guervós\inst{1}\orcidID{0000-0002-1385-9741} \and Antonio M. Mora\inst{2}\orcidID{0000-0003-1603-9105} \and Mario García-Valdez\inst{3}\orcidID{0000-0002-2593-1114}
%}
% \institute{Department of Computer Engineering, Automatics and Robotics and CITIC University of Granada, Granada, Spain \and
% Department of Signal Theory, Telematics and Communications, University of Granada, Granada, Spain \and
% Department of Graduate Studies, National Technological Institute of Mexico, Tijuana, Mexico\\
% \email{jmerelo@ugr.es, amorag@ugr.es, mario@tectijuana.edu.mx}
% }

\author{ A. U. Thorone \inst{1} \and B. U. Thortwo \inst{2} \and C. U. Thorzree \inst{1}}
\institute{ Department of Paper Publication, Miskatonic University, Arkham, MA, USA \and Department of Miscellaneous Stuff, University of Nowhere, Nowhere, ZZ, USA\\
}
\maketitle

\begin{abstract}

\keywords{Green computing, metaheuristics, energy-aware computing, evolutionary algorithms}
\end{abstract}

\section{Introduction}

We live in an era where obtaining better performance through faster hardware that besides consumes less power is no longer possible. Optimization through software is still possible at many levels, through the use of software engineering techniques or at the evolutionary algorithm level, trying to create better ways of sampling the solution space so that better solutions are found faster. However, energy consumption is also a concern, and has been in the area of evolutionary algorithms for many years already.

\section{State of the art}

\section{Methodology}

We will follow a methodology that has been already used in several other papers \cite{lion24-anon,zig1-anon,zig2-anon,icsoft23-anon}. The tool used for energy profiling is called {\sf pinpoint} \cite{pinpoint}, a multiplatform tool that taps into the RAPL API or, in the case of other platforms or operating systems, different APIs, offering a single command for measuring how much energy a process consumes. Since {\sf pinpoint} runs with a command, synchronization is not an issue, yielding system-wide energy consumption {\em while a process is running}.

This is why our methodology needs an additional step to register the actual energy consumed by the specific workload we are interested in. In order to do that, in this paper we will follow the same methodology as in other papers such as \cite{wivace23-anon}: measure a common function as baseline; averages obtained  here will be subtracted from the time and energy consumed by the functions we want to study later on.

Effectively, what we will use as baseline is chromosome generation. After all, you need to generate chromosomes to apply any kind of function to them. Time consumed in generation, however, is not critical in an evolutionary algorithm since it is done only once at algorithm startup, so we will measure it together with the energy consumed by the whole system. Besides using this as a baseline, this will give us also a measure of energy consumed by different types of data structures.

We will perform all experiments in a Linux system {\tt 5.15.0-124-generic \#134~20.04.1-Ubuntu SMP} running in an {\em AMD Ryzen 9 3950X} with 16 cores, although we will be using a single core. The compiler we will use is {\tt g++ 10.5.0}\footnote{This is admittedly not the latest version, but the most modern one that can be run in a Ubuntu 20.04}. All programs have been compiled with the flags {\tt -flto -march=native -O3 -Wall -std=c++2a}, that is, link-time optimization, native architecture, third level of optimization (which is the maximum available, {\tt -O4} might result in worse performance) that instructs the compiler to use all reasonable machine-level optimizations, all warnings, and the C++ 20 standard. In general, what we are telling the compiler is to use its own heuristics to create the best possible code for the architecture we are running on, as well as the most current standard it is able to process \footnote{Which is not the most current one, however. We do not think that the specific standard will have influence on the ranking of results, though.}.

<<evostar.bbob.setup, echo=F, message=F, fig.height=4, fig.cap="Time in seconds for every experiment generating 40K chromosomes with 128,256,512 dimensions, using float or double for every one of them">>=
library(ggplot2)
library(ggthemes)
library(dplyr)

base.variable.data <- read.csv("../data/evostar25-generation-5-Nov-07-30-15.csv")

base.variable.data$size <- as.factor(base.variable.data$size)
base.variable.data$type <- as.factor(base.variable.data$type)
ggplot(base.variable.data, aes(x=PKG, y=seconds, color=type, shape=size)) +
  geom_point() +
  labs(title="Energy consumption of BBOB functions", x="PKG Energy (Joules)", y="seconds") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

base.variable.data %>% group_by(size, type) %>% summarise(mean.seconds=mean(seconds), sd.seconds=sd(seconds), mean.PKG = mean(PKG), sd.PKG = sd(PKG)) -> summary.base.variable.data
@

The code use, which is available from this paper repository (hidden URL) has been adapted from the BBOB code \cite{hansen2010comparing} by using C++ generics to employ the same code for {\sf float} and {\sf double} types for each dimension. Since {\sf doubles} take twice as many bytes as {\sf floats}, simply going through them should have an impact on consumed energy. By default, {\sf BBOB} is programmed for {\sf doubles}; however, using float or double should not have any measurable impact on evolutionary algorithm performance. BBOB looks for a $10^{-8}$ target; this is close to {\sf float} precision (which is 6 digits without round-trip errors, 7 with some errors, 8 attainable depending on the values codified), so we could not really use {\sf float} to represent the dimension of BBOB functions. However, we are using BBOB functions as representative of floating-point fitness function, and assuming the type used to represent function values is a choice that is under control of the researcher. We are also trying to measure what is the difference in energy consumption between using {\sf float} and {\sf double}, so that this enters into consideration when creating an EA experiment. In both cases, we will use the variable-size {\sf vector} data structure from the standard library.

The other variable we are changing in these experiments is the number of dimensions, which we call {\sf size} here. We will start at 128, and double up to 512. Again, the dimensions used in BBOB stop at 100, but increasing the size will be useful to be able to measure differences in time and energy consumed with more precision.

As is usual, we have generated 40K random chromosomes, using the RNG that consumes the least, {\tt mt19937\_64} \cite{mersennetwister}, and repeated runs for every combination 30 times. The results are shown in Figure \ref{fig:evostar.bbob.setup}. What we see in this figure is that the spread in energy consumption is, as usual, much bigger than the spread in running time, which has been found elsewhere and is expected. The energy a program draws from the system depends on the ambient temperature, as well as the other programs that are running, the {\em split} observed between 10 Joules and around 14 joules for the floating point experiments with size = 512 is not surprising, and is one of the reasons why we are running 30 experiments in the first place. Other than that, what we see is that except for this case, energy consumed is not so different between float and double; while the amount of time it take is, they consume roughly the same, meaning the power drawn by double precision arithmetic is {\em lower} than for single precision. We need to take into account, however, that this is a baseline measurement that will be influenced by the system overhead; we will need to measure the actual functions to confirm these measurements.

<<evostar.bbob.fixed, echo=F, message=F, fig.height=4, fig.cap="Time in seconds for every experiment generating 40K chromosomes with 128,256,512 dimensions, using float or double for every one of them">>=
base.fixed.data <- read.csv("../data/fixed-evostar25-generation-5-Nov-07-37-13.csv")

base.fixed.data$size <- as.factor(base.fixed.data$size)
base.fixed.data$type <- as.factor(base.fixed.data$type)
base.fixed.data$work <- rep("array", nrow(base.fixed.data))

base.variable.data.128 <- base.variable.data[base.variable.data$size == 128,]
base.variable.data.128$work <- rep("vector", nrow(base.variable.data.128))

base.data.128 <- rbind(base.fixed.data, base.variable.data.128)

ggplot(base.data.128, aes(x=PKG, y=seconds, color=type, shape=work)) +
  geom_point() +
  labs(title="Energy consumption of BBOB functions, vector vs. array", x="PKG Energy (Joules)", y="seconds") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
@

We are, however, also interested in the actual type we use to represent this number vector if it has any influence in the energy it consumes. C++ includes some fixed-size types, such as {\sf array}. From the point of view of programming, this needs the array size to be constant, which means that you need to generate and compile different sources for every size; this is why we have run an experiment just for size = 128. This is shown in Figure \ref{fig:evostar.bbob.fixed}; colors again represent the type used for every number, while shape varies with the kind of data structures, fixed-sized array as dots, and variable-sized vector as triangles. There is a clear difference between the two, in running time as well as energy consumed, with the former consuming almost one eighth of the joules, and taking almost half of the time. Again, energy consumed by single and double precision is almost the same, differing only in the time it takes. Since the only operation we are applying here is random number generation, this would mean that generating random doubles consumes the same amount of energy than generating single-precision numbers\footnote{Since the RNG used is for 64 bits, it is very likely that what it is actually doing is {\em always} generating that amount of bits and then picking 4 for single-precision {\sf floats}}.

We should emphasize that that this is the baseline measurement. We will measure the energy consumed by a selected sample of BBOB functions next.

\section{Measuring energy consumption of BBOB functions}
\label{sec:measurements}

<<evostar.bbob.functions, echo=F, message=F, warning=F, fig.height=6, out.width="30%", fig.show="hold", fig.cap="PKG energy consumed in every experiment evaluating 40K chromosomes with 128, 256, 512 dimensions, using float or double for every one of them. Please note the $y$ axes have different scales">>=
functions.data <- read.csv("../data/variable-evostar25-bbob-10-Nov-19-10-32.csv")
functions.data <- functions.data[functions.data$work != "none",]
number.of.rows <- nrow(functions.data[ functions.data$size==128 & functions.data$type==" f",])
functions.data$delta.PKG <- 0
functions.data[ functions.data$size==128 & functions.data$type==" f",]$delta.PKG <- functions.data[ functions.data$size==128 & functions.data$type==" f",]$PKG - rep(summary.base.variable.data[ summary.base.variable.data$size == 128 & summary.base.variable.data$type==" f", ]$mean.PKG,number.of.rows)

functions.data[ functions.data$size==256 & functions.data$type==" f",]$delta.PKG <- functions.data[ functions.data$size==256 & functions.data$type==" f",]$PKG - rep(summary.base.variable.data[ summary.base.variable.data$size == 256 & summary.base.variable.data$type==" f", ]$mean.PKG,number.of.rows)

functions.data[ functions.data$size==512 & functions.data$type==" f",]$delta.PKG <- functions.data[ functions.data$size==512 & functions.data$type==" f",]$PKG - rep(summary.base.variable.data[ summary.base.variable.data$size == 512 & summary.base.variable.data$type==" f", ]$mean.PKG,number.of.rows)

functions.data[ functions.data$size==128 & functions.data$type==" d",]$delta.PKG <- functions.data[ functions.data$size==128 & functions.data$type==" d",]$PKG - rep(summary.base.variable.data[ summary.base.variable.data$size == 128 & summary.base.variable.data$type==" d", ]$mean.PKG,number.of.rows)

functions.data[ functions.data$size==256 & functions.data$type==" d",]$delta.PKG <- functions.data[ functions.data$size==256 & functions.data$type==" d",]$PKG - rep(summary.base.variable.data[ summary.base.variable.data$size == 256 & summary.base.variable.data$type==" d", ]$mean.PKG,number.of.rows)

functions.data[ functions.data$size==512 & functions.data$type==" d",]$delta.PKG <- functions.data[ functions.data$size==512 & functions.data$type==" d",]$PKG - rep(summary.base.variable.data[ summary.base.variable.data$size == 512 & summary.base.variable.data$type==" d", ]$mean.PKG,number.of.rows)

functions.data$delta.PKG <- pmax(functions.data$delta.PKG, 0)

ggplot(functions.data[ functions.data$size==128,], aes(x=work, y=delta.PKG, color=type)) +
  geom_boxplot() +
  labs(title="Energy consumption of BBOB functions, length=128", y="PKG Energy (Joules)", x="function") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + scale_y_log10() + theme(legend.position="none")

ggplot(functions.data[ functions.data$size==256,], aes(x=work, y=delta.PKG, color=type)) +
  geom_boxplot() +
  labs(title="Energy consumption of BBOB functions, length=256", y=NULL, x="function") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+ scale_y_log10()+ theme(legend.position="none")

ggplot(functions.data[ functions.data$size==512,], aes(x=work, y=delta.PKG, color=type)) +
  geom_boxplot() +
  labs(title="Energy consumption of BBOB functions, length=256", y=NULL, x="function") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+ scale_y_log10()
@

\section*{Acknowledgements and data availability}

Acknowledgements Taking\\
These number\\
of lines

% This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
% Competitividad (Spanish Ministry of Competitivity and Economy) under project
% PID2020-115570GB-C22 (DemocratAI::UGR). We are also very grateful to the {\sf zig} community. Source and data available from \url{https://github.com/JJ/energy-ga-icsoft-2023} under a GPL license.

\bibliographystyle{splncs04}

\bibliography{energy,ga-energy,ours,GAs,cplusplus-energy}


\end{document}

